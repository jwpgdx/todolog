# 소셜 로그인 & 구글 캘린더 연동 가이드

앱 출시 시 구현할 소셜 로그인 및 구글 캘린더 자동 연동 가이드입니다.

## 📋 개요

- **목적**: 구글/애플 소셜 로그인 + 구글 캘린더 선택적 동기화
- **예상 작업 시간**: 2-3시간
- **우선순위**: 앱 출시 준비 단계에서 구현
- **구현 상태**: ✅ 구글 로그인 웹/모바일 구현 완료 (2024-12-09)

### 구현 전략
- **로그인 시**: 기본 프로필 정보만 요청 (이메일, 이름)
- **캘린더 연동 시**: 사용자가 설정에서 토글 ON 할 때 캘린더 권한 요청
- **플랫폼별 처리**: 웹/Android/iOS 각각 다른 방식으로 구글 로그인 구현
- **장점**: 사용자 경험 향상, 권한 분리, 선택적 기능 제공

---

## 1. 📦 필요한 패키지

### 클라이언트 (client/)
```bash
# 구글 로그인 (모바일) ✅ 설치 완료
npm install @react-native-google-signin/google-signin

# 구글 로그인 (웹) ✅ 설치 완료
npm install @react-oauth/google

# 애플 로그인 (iOS만) - 추후 구현
npm install @invertase/react-native-apple-authentication
```

### 서버 (server/)
```bash
# 구글 인증 및 캘린더 API ✅ 설치 완료
npm install google-auth-library googleapis

# 애플 로그인 검증 - 추후 구현
npm install apple-signin-auth
```

---

## 2. 🔧 Google Cloud Console 설정

### 2.1 프로젝트 생성
1. [Google Cloud Console](https://console.cloud.google.com/) 접속
2. 새 프로젝트 생성 또는 기존 프로젝트 선택

### 2.2 OAuth 2.0 클라이언트 ID 생성 ✅ 웹 완료

#### 웹 클라이언트 ID (필수, 서버 검증용) ✅ 완료
1. **API 및 서비스** → **사용자 인증 정보**
2. **사용자 인증 정보 만들기** → **OAuth 2.0 클라이언트 ID**
3. **웹 애플리케이션** 선택
4. 이름: `TODOLOG` (또는 원하는 이름)
5. 승인된 JavaScript 원본/리디렉션 URI: 비워둠
6. **만들기** 클릭
7. 클라이언트 ID와 보안 비밀번호 복사 → `.env` 파일에 저장

**생성된 클라이언트 ID:**
```
399488138188-e5ee5mj2jpedtc1ojv3p1paus11sg1mn.apps.googleusercontent.com
```

#### Android 클라이언트 ID (추후 필요)
- 패키지 이름 필요
- SHA-1 인증서 지문 필요
- 실제 앱 빌드 시 생성

#### iOS 클라이언트 ID (추후 필요)
- 번들 ID 필요
- 실제 앱 빌드 시 생성

### 2.3 Calendar API 활성화
1. **API 및 서비스** → **라이브러리**
2. "Google Calendar API" 검색
3. **사용 설정** 클릭

### 2.4 OAuth 동의 화면 설정
1. **OAuth 동의 화면** 메뉴
2. 앱 정보 입력 (이름, 로고, 이메일 등)
3. **범위 추가** → 다음 권한 추가:
   - `https://www.googleapis.com/auth/calendar.events` (캘린더 이벤트 읽기/쓰기)
   - `https://www.googleapis.com/auth/userinfo.email`
   - `https://www.googleapis.com/auth/userinfo.profile`

---

## 3. 🍎 Apple Developer 설정

### 3.1 Sign in with Apple 활성화
1. [Apple Developer](https://developer.apple.com/) 접속
2. **Certificates, Identifiers & Profiles**
3. **Identifiers** → 앱 선택
4. **Sign in with Apple** 체크박스 활성화

### 3.2 Service ID 생성
1. **Identifiers** → **+** 버튼
2. **Services IDs** 선택
3. Description과 Identifier 입력
4. **Sign in with Apple** 설정
5. Return URLs 추가 (웹 리디렉션용)

---

## 4. 💻 클라이언트 구현

### 4.1 구글 로그인 설정 ✅ 구현 완료

#### 모바일용 설정 (Android/iOS)
```javascript
// client/src/config/googleSignIn.js
import { GoogleSignin } from '@react-native-google-signin/google-signin';

GoogleSignin.configure({
  webClientId: '399488138188-e5ee5mj2jpedtc1ojv3p1paus11sg1mn.apps.googleusercontent.com',
  offlineAccess: true, // 리프레시 토큰 받기
  scopes: [
    'https://www.googleapis.com/auth/userinfo.email',
    'https://www.googleapis.com/auth/userinfo.profile',
  ],
});
```

#### 웹용 설정
```javascript
// client/App.js
import { GoogleOAuthProvider } from '@react-oauth/google';

const GOOGLE_CLIENT_ID = '399488138188-e5ee5mj2jpedtc1ojv3p1paus11sg1mn.apps.googleusercontent.com';

// 웹에서는 GoogleOAuthProvider로 감싸기
if (Platform.OS === 'web') {
  return (
    <GoogleOAuthProvider clientId={GOOGLE_CLIENT_ID}>
      {AppContent}
    </GoogleOAuthProvider>
  );
}
```

**주의**: 로그인 시에는 캘린더 권한을 요청하지 않습니다. 사용자가 설정에서 연동을 활성화할 때만 요청합니다.

### 4.2 구글 로그인 함수 ✅ 구현 완료 (웹/모바일 분기 처리)

```javascript
// client/src/hooks/useGoogleSignIn.js
import { useState } from 'react';
import { Platform } from 'react-native';
import GoogleSignin from '../config/googleSignIn';
import api from '../api/axios';

export const useGoogleSignIn = () => {
  const [isLoading, setIsLoading] = useState(false);

  // 모바일용 구글 로그인
  const signInMobile = async () => {
    await GoogleSignin.hasPlayServices();
    const userInfo = await GoogleSignin.signIn();
    
    // 서버로 ID 토큰 전송
    const response = await api.post('/auth/google', {
      idToken: userInfo.idToken,
    });
    
    return response.data;
  };

  // 웹용 구글 로그인 (access token + userInfo)
  const signInWeb = async (accessToken, userInfo) => {
    const response = await api.post('/auth/google/web', {
      accessToken,
      email: userInfo.email,
      name: userInfo.name,
      googleId: userInfo.sub,
    });
    
    return response.data;
  };

  const signIn = async (credentialOrToken, userInfo) => {
    try {
      setIsLoading(true);
      
      if (Platform.OS === 'web') {
        // 웹: access token + userInfo
        return await signInWeb(credentialOrToken, userInfo);
      } else {
        // 모바일: 직접 로그인
        return await signInMobile();
      }
    } catch (error) {
      console.error('Google Sign In Error:', error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  // 캘린더 권한 요청 (설정에서 연동 ON 시)
  const requestCalendarAccess = async () => {
    try {
      setIsLoading(true);
      
      await GoogleSignin.addScopes({
        scopes: ['https://www.googleapis.com/auth/calendar.events'],
      });
      
      const tokens = await GoogleSignin.getTokens();
      
      const response = await api.post('/auth/google/calendar', {
        accessToken: tokens.accessToken,
        refreshToken: tokens.refreshToken,
      });
      
      return response.data;
    } catch (error) {
      console.error('Calendar Access Request Error:', error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  return { signIn, requestCalendarAccess, isLoading };
};
```

### 4.3 애플 로그인 함수

```javascript
// client/src/hooks/useAppleSignIn.js
import { appleAuth } from '@invertase/react-native-apple-authentication';

export const useAppleSignIn = () => {
  const signIn = async () => {
    try {
      const appleAuthRequestResponse = await appleAuth.performRequest({
        requestedOperation: appleAuth.Operation.LOGIN,
        requestedScopes: [appleAuth.Scope.EMAIL, appleAuth.Scope.FULL_NAME],
      });

      // 서버로 토큰 전송
      const response = await api.post('/auth/apple', {
        identityToken: appleAuthRequestResponse.identityToken,
        user: appleAuthRequestResponse.user,
      });

      return response.data;
    } catch (error) {
      console.error('Apple Sign In Error:', error);
      throw error;
    }
  };

  return { signIn };
};
```

### 4.4 LoginScreen 수정 ✅ 구현 완료 (웹/모바일 분기)

```javascript
// client/src/screens/LoginScreen.js
import { Platform } from 'react-native';
import { useGoogleLogin } from '@react-oauth/google';
import { useGoogleSignIn } from '../hooks/useGoogleSignIn';
import { useAuthStore } from '../store/authStore';
import Toast from 'react-native-toast-message';

export default function LoginScreen() {
  const { signIn: googleSignIn, isLoading: isGoogleLoading } = useGoogleSignIn();
  const { setAuth } = useAuthStore();

  // 웹용 구글 로그인
  const webGoogleLogin = useGoogleLogin({
    onSuccess: async (codeResponse) => {
      try {
        // access_token으로 사용자 정보 가져오기
        const userInfoResponse = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
          headers: { Authorization: `Bearer ${codeResponse.access_token}` },
        });
        const userInfo = await userInfoResponse.json();
        
        const { token, user } = await googleSignIn(codeResponse.access_token, userInfo);
        await setAuth(token, user);
        Toast.show({
          type: 'success',
          text1: '구글 로그인 성공',
        });
      } catch (error) {
        Toast.show({
          type: 'error',
          text1: '구글 로그인 실패',
        });
      }
    },
  });

  // 모바일용 구글 로그인
  const handleGoogleSignIn = async () => {
    if (Platform.OS === 'web') {
      webGoogleLogin();
      return;
    }

    try {
      const { token, user } = await googleSignIn();
      await setAuth(token, user);
      Toast.show({
        type: 'success',
        text1: '구글 로그인 성공',
      });
    } catch (error) {
      Toast.show({
        type: 'error',
        text1: '구글 로그인 실패',
      });
    }
  };

  return (
    <View>
      {/* 기존 이메일 로그인 */}
      
      {/* 구글 로그인 버튼 (웹/모바일 모두 표시) */}
      <TouchableOpacity onPress={handleGoogleSignIn} disabled={isGoogleLoading}>
        <Text>{isGoogleLoading ? '로그인 중...' : '🔍 Google로 로그인'}</Text>
      </TouchableOpacity>
      
      {/* 애플 로그인 버튼 (iOS만) - 추후 구현 */}
    </View>
  );
}
```

### 4.5 ProfileScreen에 캘린더 연동 토글 추가 (추후 구현)

```javascript
// client/src/screens/ProfileScreen.js
import { useGoogleSignIn } from '../hooks/useGoogleSignIn';

export default function ProfileScreen() {
  const { user } = useAuthStore();
  const { requestCalendarAccess } = useGoogleSignIn();
  const [isCalendarEnabled, setIsCalendarEnabled] = useState(user?.hasCalendarAccess);

  const handleToggleCalendar = async (value) => {
    if (value) {
      // 연동 ON
      try {
        await requestCalendarAccess();
        setIsCalendarEnabled(true);
        Toast.show({
          type: 'success',
          text1: '구글 캘린더 연동 완료',
        });
      } catch (error) {
        Toast.show({
          type: 'error',
          text1: '캘린더 연동 실패',
        });
      }
    } else {
      // 연동 OFF (서버에서 토큰 삭제)
      await api.post('/auth/google/calendar/disconnect');
      setIsCalendarEnabled(false);
    }
  };

  return (
    <View>
      {user?.provider === 'google' && (
        <View>
          <Text>구글 캘린더 연동</Text>
          <Switch
            value={isCalendarEnabled}
            onValueChange={handleToggleCalendar}
          />
        </View>
      )}
    </View>
  );
}
```

---

## 5. 🖥️ 서버 구현

### 5.1 구글 토큰 검증 ✅ 구현 완료

```javascript
// server/src/controllers/authController.js
const { OAuth2Client } = require('google-auth-library');
const client = new OAuth2Client(process.env.GOOGLE_CLIENT_ID);

// 기본 로그인 (프로필 정보만)
exports.googleLogin = async (req, res) => {
  try {
    const { idToken } = req.body;
    
    // 토큰 검증
    const ticket = await client.verifyIdToken({
      idToken,
      audience: process.env.GOOGLE_CLIENT_ID,
    });
    
    const payload = ticket.getPayload();
    const { email, name, sub: googleId } = payload;
    
    // 사용자 찾기 또는 생성
    let user = await User.findOne({ email });
    if (!user) {
      user = await User.create({
        email,
        name,
        googleId,
        provider: 'google',
      });
    } else if (!user.googleId) {
      // 기존 이메일 계정을 구글 계정으로 연결
      user.googleId = googleId;
      user.provider = 'google';
      await user.save();
    }
    
    // JWT 토큰 생성
    const token = jwt.sign({ userId: user._id }, process.env.JWT_SECRET);
    
    res.json({ token, user });
  } catch (error) {
    console.error('Google login error:', error);
    res.status(401).json({ message: '구글 로그인 실패' });
  }
};

// 캘린더 권한 저장 (설정에서 연동 ON 시)
exports.updateCalendarAccess = async (req, res) => {
  try {
    const { accessToken, refreshToken } = req.body;
    const userId = req.userId; // auth 미들웨어에서 추출
    
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ message: '사용자를 찾을 수 없습니다' });
    }
    
    // Access Token 저장
    user.googleAccessToken = accessToken;
    user.googleRefreshToken = refreshToken;
    user.hasCalendarAccess = true;
    await user.save();
    
    res.json({ message: '캘린더 연동 완료', hasCalendarAccess: true });
  } catch (error) {
    console.error('Calendar access error:', error);
    res.status(500).json({ message: '캘린더 연동 실패' });
  }
};

// 캘린더 연동 해제
exports.disconnectCalendar = async (req, res) => {
  try {
    const userId = req.userId;
    
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ message: '사용자를 찾을 수 없습니다' });
    }
    
    // 토큰 삭제
    user.googleAccessToken = null;
    user.googleRefreshToken = null;
    user.hasCalendarAccess = false;
    await user.save();
    
    res.json({ message: '캘린더 연동 해제 완료' });
  } catch (error) {
    console.error('Disconnect calendar error:', error);
    res.status(500).json({ message: '연동 해제 실패' });
  }
};
```

### 5.2 애플 토큰 검증

```javascript
// server/src/controllers/authController.js
const appleSignin = require('apple-signin-auth');

exports.appleLogin = async (req, res) => {
  try {
    const { identityToken, user } = req.body;
    
    // 토큰 검증
    const appleUser = await appleSignin.verifyIdToken(identityToken, {
      audience: process.env.APPLE_CLIENT_ID,
    });
    
    const { email, sub: appleId } = appleUser;
    
    // 사용자 찾기 또는 생성
    let dbUser = await User.findOne({ email });
    if (!dbUser) {
      dbUser = await User.create({
        email,
        name: user?.fullName?.givenName || 'User',
        appleId,
        provider: 'apple',
      });
    }
    
    // JWT 토큰 생성
    const token = jwt.sign({ userId: dbUser._id }, process.env.JWT_SECRET);
    
    res.json({ token, user: dbUser });
  } catch (error) {
    res.status(401).json({ message: '애플 로그인 실패' });
  }
};
```

### 5.3 User 모델 수정 ✅ 구현 완료

```javascript
// server/src/models/User.js
const userSchema = new mongoose.Schema({
  email: { type: String, required: true, unique: true },
  password: { type: String }, // 소셜 로그인은 비밀번호 없음
  name: { type: String },
  provider: { type: String, enum: ['local', 'google', 'apple'], default: 'local' },
  googleId: { type: String },
  appleId: { type: String },
  googleAccessToken: { type: String }, // 구글 캘린더 API용
  googleRefreshToken: { type: String },
  hasCalendarAccess: { type: Boolean, default: false }, // 캘린더 연동 여부
}, { timestamps: true });
```

### 5.4 라우트 추가 ✅ 구현 완료

```javascript
// server/src/routes/auth.js
const express = require('express');
const router = express.Router();
const authController = require('../controllers/authController');
const auth = require('../middlewares/auth');

// 기존 라우트
router.post('/register', authController.register);
router.post('/login', authController.login);

// 구글 로그인
router.post('/google', authController.googleLogin); // 모바일용 (ID Token)
router.post('/google/web', authController.googleLoginWeb); // 웹용 (Access Token)

// 구글 캘린더 연동 (인증 필요)
router.post('/google/calendar', auth, authController.updateCalendarAccess);
router.post('/google/calendar/disconnect', auth, authController.disconnectCalendar);

module.exports = router;
```

### 5.5 웹용 구글 로그인 API ✅ 구현 완료

```javascript
// server/src/controllers/authController.js
exports.googleLoginWeb = async (req, res) => {
  try {
    const { accessToken, email, name, googleId } = req.body;

    if (!email || !googleId) {
      return res.status(400).json({ message: '필수 정보가 누락되었습니다' });
    }

    // 사용자 찾기 또는 생성
    let user = await User.findOne({ email });
    
    if (!user) {
      user = await User.create({
        email,
        name,
        googleId,
        provider: 'google',
      });
    } else if (!user.googleId) {
      user.googleId = googleId;
      user.provider = 'google';
      await user.save();
    }

    // JWT 토큰 생성
    const token = jwt.sign({ userId: user._id }, process.env.JWT_SECRET, {
      expiresIn: '7d',
    });

    res.json({
      token,
      user: { 
        id: user._id, 
        email: user.email, 
        name: user.name,
        provider: user.provider,
        hasCalendarAccess: !!user.googleAccessToken,
      },
    });
  } catch (error) {
    console.error('Google web login error:', error);
    res.status(401).json({ message: '구글 로그인 실패', error: error.message });
  }
};
```

---

## 6. 📅 구글 캘린더 연동 (추후 구현)

### 6.1 연동 흐름

1. **로그인 시**: 기본 프로필 정보만 받음 (캘린더 권한 ❌)
2. **설정에서 연동 ON**: 
   - 사용자가 ProfileScreen에서 토글 활성화
   - `requestCalendarAccess()` 호출
   - 캘린더 권한 요청 팝업 표시
   - 승인 시 Access Token 서버에 저장
3. **일정 추가 시**: 
   - `hasCalendarAccess === true`인 경우에만 구글 캘린더에 자동 등록
   - 실패해도 Todo는 정상 생성됨

### 6.2 캘린더 이벤트 생성 (추후 구현)

```javascript
// server/src/services/googleCalendar.js
const { google } = require('googleapis');

exports.createCalendarEvent = async (user, todo) => {
  // 캘린더 연동이 활성화되지 않은 경우 스킵
  if (!user.hasCalendarAccess || !user.googleAccessToken) {
    return null;
  }

  try {
    const oauth2Client = new google.auth.OAuth2(
      process.env.GOOGLE_CLIENT_ID,
      process.env.GOOGLE_CLIENT_SECRET
    );
    
    oauth2Client.setCredentials({
      access_token: user.googleAccessToken,
      refresh_token: user.googleRefreshToken,
    });
    
    const calendar = google.calendar({ version: 'v3', auth: oauth2Client });
    
    const event = {
      summary: todo.title,
      description: todo.memo,
      start: {
        date: todo.date, // 종일 이벤트
      },
      end: {
        date: todo.endDate || todo.date,
      },
    };
    
    // 루틴이면 반복 규칙 추가
    if (todo.type === 'routine') {
      const freq = todo.routine.frequency.toUpperCase();
      let rrule = `RRULE:FREQ=${freq}`;
      
      if (freq === 'WEEKLY' && todo.routine.weekdays) {
        const days = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];
        const byday = todo.routine.weekdays.map(d => days[d]).join(',');
        rrule += `;BYDAY=${byday}`;
      }
      
      if (todo.routine.endDate) {
        rrule += `;UNTIL=${todo.routine.endDate.replace(/-/g, '')}`;
      }
      
      event.recurrence = [rrule];
    }
    
    const response = await calendar.events.insert({
      calendarId: 'primary',
      resource: event,
    });
    
    return response.data;
  } catch (error) {
    console.error('Calendar event creation failed:', error);
    
    // Access Token 만료 시 Refresh Token으로 갱신
    if (error.code === 401) {
      // TODO: Refresh Token으로 새 Access Token 받기
    }
    
    throw error;
  }
};
```

### 6.3 Todo 생성 시 캘린더 연동 (추후 구현)

```javascript
// server/src/controllers/todoController.js
const { createCalendarEvent } = require('../services/googleCalendar');

exports.createTodo = async (req, res) => {
  try {
    // ... 기존 Todo 생성 코드
    
    const todo = await new Todo({ ... }).save();
    
    // 구글 캘린더에 추가 (연동 활성화된 사용자만)
    const user = await User.findById(req.userId);
    if (user.hasCalendarAccess && todo.type !== 'routine') {
      try {
        const calendarEvent = await createCalendarEvent(user, todo);
        if (calendarEvent) {
          // 캘린더 이벤트 ID 저장 (추후 수정/삭제 시 사용)
          todo.googleCalendarEventId = calendarEvent.id;
          await todo.save();
        }
      } catch (error) {
        console.error('Failed to sync with Google Calendar:', error);
        // 캘린더 동기화 실패해도 Todo는 생성됨
      }
    }
    
    res.status(201).json(todo);
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
};
```

---

## 7. 📝 환경 변수 설정 ✅ 구현 완료

```env
# server/.env
GOOGLE_CLIENT_ID=your_google_client_id
GOOGLE_CLIENT_SECRET=your_google_client_secret

# 추후 애플 로그인 구현 시
APPLE_CLIENT_ID=your_apple_client_id
APPLE_TEAM_ID=your_apple_team_id
APPLE_KEY_ID=your_apple_key_id
```

---

## 7-1. 구글 캘린더 연동 구현 완료 (2024-12-12)

### 🎯 구현 완료된 기능

#### 1단계: 데이터베이스 스키마 확장 ✅
- ✅ `server/src/models/Todo.js` - syncStatus, lastSyncAttempt 필드 추가
- ✅ `server/src/models/User.js` - todoLogCalendarId 필드 추가

#### 2단계: Todo 생성 시 캘린더 이벤트 자동 생성 ✅
- ✅ `server/src/controllers/todoController.js` - createTodo에 캘린더 동기화 로직 추가
- ✅ `server/src/services/googleCalendar.js` - TODOLOG 전용 캘린더 생성 및 관리
- ✅ todo 타입만 동기화, routine 제외

#### 3단계: Todo 수정 시 캘린더 이벤트 업데이트 ✅
- ✅ `server/src/controllers/todoController.js` - updateTodo에 캘린더 동기화 로직 추가
- ✅ 타입 변경 시 이벤트 생성/삭제 처리

#### 4단계: Todo 삭제 시 캘린더 이벤트 삭제 ✅
- ✅ `server/src/controllers/todoController.js` - deleteTodo에 캘린더 이벤트 삭제 로직 추가
- ✅ 실패해도 Todo 삭제는 정상 진행

#### 5단계: 동기화 실패 시 재시도 UI ✅
- ✅ `client/src/components/domain/todo/TodoItem.js` - 실패 시 재시도 버튼 표시
- ✅ `client/src/screens/ProfileScreen.js` - 일괄 재시도 기능 추가
- ✅ `client/src/hooks/queries/useRetryCalendarSync.js` - 재시도 React Query Hook
- ✅ `server/src/routes/todos.js` - 재시도 API 엔드포인트 추가
- ✅ `client/src/api/todos.js` - 재시도 API 함수 추가

#### 6단계: TODOLOG 전용 캘린더 생성 로직 ✅
- ✅ `server/src/services/googleCalendar.js` - ensureTodoLogCalendar 메서드 구현
- ✅ 구글 캘린더에 "TODOLOG" 전용 캘린더 생성
- ✅ 캘린더 삭제 시 자동 재생성

### 🔧 주요 구현 특징

#### 단방향 동기화
- **방향**: 앱 → 구글 캘린더만 지원
- **타입 제한**: todo(특정날짜) 타입만 동기화
- **제외 타입**: routine 할일은 캘린더에 추가하지 않음

#### 실패 처리 및 재시도
- **실패 허용**: 캘린더 동기화 실패해도 할일 CRUD는 정상 동작
- **상태 추적**: syncStatus (synced/pending/failed) 필드로 동기화 상태 관리
- **개별 재시도**: TodoItem에 재시도 버튼 표시
- **일괄 재시도**: ProfileScreen에서 실패한 모든 할일 일괄 재시도

#### 전용 캘린더 관리
- **캘린더 이름**: "TODOLOG"
- **자동 생성**: 첫 동기화 시 자동으로 생성
- **복구 기능**: 캘린더 삭제 시 자동 재생성
- **ID 저장**: User 모델에 todoLogCalendarId 저장

#### 시간 처리
- **시간 없음**: 종일 이벤트로 생성
- **시작시간만**: 1시간 duration으로 생성
- **시작+종료시간**: 정확한 duration으로 생성
- **기간 할일**: 다중일 이벤트로 생성

### 📝 API 엔드포인트 추가

```javascript
// 개별 재시도
POST /api/todos/retry-sync/:id

// 일괄 재시도
POST /api/todos/retry-all-sync
```

### 🎨 UI 개선사항

#### TodoItem 컴포넌트
- syncStatus가 'failed'인 경우 재시도 버튼 표시
- "📅 구글캘린더 등록 재시도" 버튼 추가

#### ProfileScreen 컴포넌트
- "실패한 캘린더 동기화 일괄 재시도" 버튼 추가
- 캘린더 동기화 활성화 시에만 표시

#### 7단계: 구글 캘린더 연동 디버깅 및 완료 ✅ (2024-12-12 오후)
- ✅ **권한 문제 해결**: `calendar.events` → `calendar` 스코프로 변경
- ✅ **웹용 인증 개선**: `flow: 'auth-code'` 사용으로 refresh_token 획득
- ✅ **서버 API 추가**: `/auth/google/calendar/code` - 인증 코드를 토큰으로 교환
- ✅ **디버깅 로그 추가**: 전체 플로우에 상세한 로그 추가
- ✅ **실제 동작 확인**: TODOLOG 캘린더 생성 및 이벤트 동기화 성공

#### 8단계: 할일 수정 기능 개선 ✅ (2024-12-12 오후)
- ✅ **EditTodoScreen 개선**: todo 타입 할일의 날짜 수정 가능
- ✅ **시간 입력 개선**: startTime/endTime 분리, TimeInput 컴포넌트 사용
- ✅ **날짜 유효성 검사**: 종료일 ≥ 시작일 체크
- ✅ **타입별 UI**: todo(날짜+시간), routine(시간만) 구분

#### 9단계: 입력 유효성 검사 강화 ✅ (2024-12-12 오후)
- ✅ **DateInput 컴포넌트**: `allowClear` prop 추가로 지우기 버튼 제어
- ✅ **필수 날짜 보호**: todo/routine 타입의 시작날짜 지우기 방지
- ✅ **AddTodoScreen**: todo/routine 타입 시작날짜 필수 체크
- ✅ **EditTodoScreen**: todo 타입 시작날짜 필수 체크

---

## 🎉 구글 캘린더 연동 완전 구현 완료! (2024-12-12)

### ✨ 최종 구현 결과

#### 완벽한 동기화 플로우
1. **권한 요청**: ProfileScreen에서 캘린더 토글 ON → 구글 권한 승인
2. **캘린더 생성**: "TODOLOG" 전용 캘린더 자동 생성
3. **이벤트 동기화**: todo 타입 할일 → 구글 캘린더 이벤트 자동 생성
4. **실시간 업데이트**: 할일 수정/삭제 시 캘린더 이벤트도 동기화

#### 강화된 사용자 경험
- **유연한 수정**: todo 타입 할일의 날짜 수정 가능
- **입력 보호**: 필수 날짜 실수로 삭제 방지
- **타입별 UI**: 각 할일 타입에 맞는 최적화된 입력 화면
- **상세한 피드백**: 디버깅 로그로 문제 발생 시 빠른 해결

### 🧪 테스트 완료 항목
1. ✅ **구글 로그인 및 캘린더 권한 요청**
2. ✅ **Todo 생성 시 캘린더 이벤트 생성**
3. ✅ **Todo 수정 시 캘린더 이벤트 업데이트**
4. ✅ **Todo 삭제 시 캘린더 이벤트 삭제**
5. ✅ **TODOLOG 캘린더 생성 및 관리**
6. ✅ **입력 유효성 검사 및 오류 방지**

---

## 7-2. 기존 구현 완료 파일 목록 (2024-12-10)

### Google Cloud Console ✅
- ✅ 프로젝트 생성: `to-dolog` (프로젝트 ID: 399488138188)
- ✅ OAuth 동의 화면 설정 완료
- ✅ 웹 클라이언트 ID 생성 완료
- ✅ 클라이언트 ID: `399488138188-e5ee5mj2jpedtc1ojv3p1paus11sg1mn.apps.googleusercontent.com`
- ✅ 승인된 JavaScript 원본 추가: `http://localhost:8081`
- ✅ 승인된 리디렉션 URI 추가: `http://localhost:8081`
- ✅ Calendar API 활성화
- ✅ OAuth 범위 추가: `calendar.events`, `userinfo.email`, `userinfo.profile`
- ✅ 테스트 사용자 추가

### 클라이언트 ✅
- ✅ `client/App.js` - 웹용 GoogleOAuthProvider 추가, QueryClient를 authStore에 주입
- ✅ `client/src/config/googleSignIn.js` - 모바일용 구글 로그인 설정
- ✅ `client/src/hooks/useGoogleSignIn.js` - 웹/모바일 분기 처리
- ✅ `client/src/hooks/useCalendarSync.js` - 캘린더 동기화 ON/OFF Hook (웹/모바일 통합)
- ✅ `client/src/hooks/queries/useShowCompletedTodos.js` - 완료된 할일 표시 설정 Hook (2024-12-10 추가)
- ✅ `client/src/hooks/queries/useToggleCompletion.js` - 기간 할일 완료 로직 개선 (2024-12-10 수정)
- ✅ `client/src/screens/LoginScreen.js` - 웹/모바일 구글 로그인 버튼
- ✅ `client/src/screens/AddTodoScreen.js` - 캘린더 연동 토글 UI, 마지막 사용 타입 기억, 기간 할일 설정
- ✅ `client/src/screens/ProfileScreen.js` - 캘린더 동기화 토글, 보기 옵션 메뉴 추가 (2024-12-10 수정)
- ✅ `client/src/screens/TodoScreen.js` - 보기 옵션 아이콘 추가 (2024-12-10 수정)
- ✅ `client/src/screens/ViewOptionsScreen.js` - 보기 옵션 전용 페이지 (2024-12-10 추가)
- ✅ `client/src/components/domain/todo/TodoList.js` - 완료된 할일 필터링, 완료 축하 메시지 (2024-12-10 수정)
- ✅ `client/src/navigation/MainStack.js` - ViewOptionsScreen 라우트 추가 (2024-12-10 추가)
- ✅ `client/src/api/todos.js` - 기간 할일 완료 API 수정 (2024-12-10 수정)
- ✅ `client/src/store/authStore.js` - 로그아웃 시 Query 캐시 초기화, setUser 함수 추가
- ✅ `client/src/hooks/queries/useCreateTodo.js` - 할일 생성 후 user 정보 갱신
- ✅ 패키지 설치: `@react-native-google-signin/google-signin`, `@react-oauth/google`

### 서버 ✅
- ✅ `server/src/models/User.js` - 캘린더 관련 필드 추가
  - `hasCalendarAccess`: 인증 정보 보유 여부
  - `calendarSyncEnabled`: 동기화 ON/OFF 상태
  - `lastUsedTodoType`: 마지막 사용 할일 타입
  - `showCompletedTodos`: 완료된 할일 표시 설정 (2024-12-10 추가)
- ✅ `server/src/models/Todo.js` - `googleCalendarEventId` 필드 추가
- ✅ `server/src/controllers/authController.js` - 구글 로그인 API (모바일/웹), 캘린더 토글 API, 보기 옵션 설정 API
- ✅ `server/src/controllers/todoController.js` - 할일 생성 시 `lastUsedTodoType` 업데이트, 기간 할일 조회 로직
- ✅ `server/src/controllers/completionController.js` - 기간 할일 완료 로직 개선 (2024-12-10 수정)
- ✅ `server/src/routes/auth.js` - 캘린더 관련 라우트 추가
  - `/auth/google/calendar` - 캘린더 인증
  - `/auth/google/calendar/toggle` - 동기화 ON/OFF
  - `/auth/google/calendar/disconnect` - 인증 정보 삭제
  - `/auth/show-completed-todos` - 완료된 할일 표시 설정 (2024-12-10 추가)
- ✅ `server/.env` - GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET 설정
- ✅ 패키지 설치: `google-auth-library`, `googleapis`

### 주요 기능 ✅
- ✅ 구글 로그인 (웹/모바일)
- ✅ 캘린더 동기화 ON/OFF (인증 정보 유지)
- ✅ 인증 정보 삭제 (명시적 삭제)
- ✅ 할일 추가 화면에서 캘린더 연동 토글
- ✅ 내 정보 화면에서 캘린더 설정 관리
- ✅ 마지막 사용 할일 타입 기억 (UX 개선)
- ✅ 단일 진실 공급원: `user.calendarSyncEnabled` (AsyncStorage 제거)
- ✅ 언젠가 섹션 접기/펼치기 상태 서버 동기화 (2024-12-10 추가)
- ✅ 언젠가 섹션 보기 개수 설정 (3개씩/5개씩/전체보기, 드롭다운 UI, 2024-12-10 추가)
- ✅ 보기 옵션 전용 페이지 (ViewOptionsScreen, 2024-12-10 추가)
- ✅ 완료된 할일 표시 설정 (표시/숨김 토글, 2024-12-10 추가)
- ✅ 기간 할일 완료 로직 개선 (한 번 완료로 전체 기간 적용, 2024-12-10 수정)
- ✅ 완료 축하 메시지 (모든 할일 완료 시 성취감 제공, 2024-12-10 추가)

### 버그 수정 ✅
- ✅ 로그아웃 시 이전 사용자 데이터가 잠깐 보이는 문제 해결 (Query 캐시 초기화)
- ✅ 캘린더 동기화 상태 동기화 문제 해결 (AsyncStorage 제거, user 객체로 통합)
- ✅ 언젠가 섹션 접기/펼치기 상태 다른 기기 동기화 문제 해결 (AsyncStorage → 서버 저장, 2024-12-10)
- ✅ 언젠가 섹션 드롭다운 z-index 문제 해결 (할일 아이템에 가려지는 문제, 2024-12-10)
- ✅ 기간 할일 완료 로직 문제 해결 (한 번 완료로 전체 기간 적용, 2024-12-10)

---

## 7-3. 추후 구현 필요 항목 (2024-12-12 업데이트)

### 🎯 새로운 구상에 따른 구현 계획

#### 동기화 범위 변경
- ✅ **기존**: todo + routine 동기화
- 🔄 **신규**: **todo(특정날짜)만 동기화**, routine은 제외
- 📝 **이유**: 캘린더 복잡성 감소, 단순한 사용자 경험

#### 전용 캘린더 생성
- 🔄 **신규**: "TODOLOG" 이름의 전용 캘린더 생성 및 ID 저장
- 📝 **User 모델 추가**: `todoLogCalendarId` 필드
- 📝 **캘린더 복구**: 삭제된 경우 자동 재생성

#### 동기화 상태 추적
- 🔄 **Todo 모델 추가 필드**:
  - `googleCalendarEventId`: 구글 캘린더 이벤트 ID
  - `syncStatus`: 'synced' | 'pending' | 'failed'
  - `lastSyncAttempt`: 마지막 동기화 시도 시간

#### 재시도 메커니즘
- 🔄 **홈화면**: 실패한 할일에 "구글캘린더 등록 재시도" 버튼
- 🔄 **설정화면**: 일괄 재시도 기능
- 📝 **UI 예시**: `[ ] 우유마시기 (구글캘린더 등록 재시도버튼)`

### 서버 - 캘린더 동기화 로직
- [ ] `server/src/services/googleCalendar.js` - 캘린더 이벤트 생성/수정/삭제
- [ ] **TODOLOG 전용 캘린더 생성** 및 ID 저장 로직
- [ ] Todo 생성 시 캘린더 이벤트 자동 생성 (**todo 타입만**, routine 제외)
- [ ] Todo 수정 시 캘린더 이벤트 업데이트
- [ ] Todo 삭제 시 캘린더 이벤트 삭제
- [ ] **동기화 실패 시 상태 추적** (syncStatus = 'failed')
- [ ] **재시도 API** 구현
- [ ] Access Token 만료 시 Refresh Token으로 갱신
- [ ] **기간 할일** → 다중일 종일/시간 이벤트 생성
- [ ] **시간 처리**: 시간 없음(종일), 시작시간만(1시간), 시작+종료시간(정확한 duration)

### 클라이언트
- [ ] **재시도 UI 구현**: 홈화면에 실패한 할일 재시도 버튼
- [ ] **설정화면 일괄 재시도**: 여러 실패 항목 한번에 처리
- [ ] **동기화 상태 표시**: 실패한 경우만 UI에 표시
- [ ] 애플 로그인 구현 (iOS)

### 테스트
- [ ] **TODOLOG 전용 캘린더 생성** 테스트
- [ ] **todo 타입만 동기화** 확인 (routine 제외)
- [ ] **동기화 실패 시 재시도 버튼** 표시 확인
- [ ] **기간 할일** 다중일 이벤트 생성 확인
- [ ] **시간 처리** 로직 확인 (종일/1시간/정확한 duration)
- [ ] 웹에서 캘린더 동기화 테스트
- [ ] 모바일에서 캘린더 동기화 테스트 (Android/iOS 클라이언트 ID 필요)

---

## 7-4. 환경 변수 설정

```env
# server/.env
GOOGLE_CLIENT_ID=your_google_client_id
GOOGLE_CLIENT_SECRET=your_google_client_secret
APPLE_CLIENT_ID=your_apple_client_id
APPLE_TEAM_ID=your_apple_team_id
APPLE_KEY_ID=your_apple_key_id
```

---

## 8. ✅ 체크리스트

### Google Cloud Console
- [x] 프로젝트 생성 (to-dolog)
- [x] OAuth 동의 화면 설정
- [x] 권한 범위 추가 (userinfo.email, userinfo.profile)
- [x] 웹 클라이언트 ID 생성 ✅
- [ ] Android 클라이언트 ID 생성 (앱 빌드 시)
- [ ] iOS 클라이언트 ID 생성 (앱 빌드 시)
- [ ] Calendar API 활성화 (캘린더 연동 시)

### Apple Developer (추후 구현)
- [ ] Sign in with Apple 활성화
- [ ] Service ID 생성
- [ ] Return URLs 설정

### 클라이언트 ✅ 웹/모바일 구글 로그인 완료
- [x] 패키지 설치 (@react-native-google-signin/google-signin, @react-oauth/google)
- [x] 구글 로그인 설정 (config/googleSignIn.js)
- [x] useGoogleSignIn Hook 구현 (웹/모바일 분기)
- [x] App.js에 GoogleOAuthProvider 추가 (웹)
- [x] LoginScreen UI 수정 (웹/모바일 통합)
- [x] 웹에서 구글 로그인 테스트 가능 ✅
- [ ] Android/iOS 실제 기기 테스트 (클라이언트 ID 추가 필요)
- [ ] ProfileScreen에 캘린더 연동 토글 추가
- [ ] 애플 로그인 구현 (iOS)

### 서버 ✅ 웹/모바일 API 완료
- [x] 패키지 설치 (google-auth-library, googleapis)
- [x] 구글 토큰 검증 구현 (모바일용 ID Token)
- [x] 웹용 구글 로그인 API 구현 (Access Token)
- [x] User 모델 수정 (hasCalendarAccess 필드)
- [x] 캘린더 권한 API 구현 (/auth/google/calendar)
- [x] 환경 변수 설정 완료
- [ ] 구글 캘린더 서비스 구현 (services/googleCalendar.js)
- [ ] Todo 생성 시 자동 동기화
- [ ] 애플 토큰 검증 구현

---

## 9. 🚀 테스트

### 현재 테스트 가능 항목 ✅
1. **구글 로그인 테스트 (웹)** ✅ 완료
   - [x] 웹 브라우저에서 로그인 성공 확인
   - [x] 사용자 정보 저장 확인 (email, name, googleId)
   - [x] JWT 토큰 발급 확인
   - [x] 로그아웃 시 Query 캐시 초기화 확인
   - [x] 다른 계정으로 재로그인 시 데이터 분리 확인

2. **구글 로그인 테스트 (모바일)** - Android/iOS 클라이언트 ID 생성 후
   - [ ] Android 실제 기기에서 로그인 테스트
   - [ ] iOS 실제 기기에서 로그인 테스트

### 추후 테스트 항목
3. **구글 캘린더 연동 테스트**
   - [ ] ProfileScreen에서 토글 ON
   - [ ] 캘린더 권한 요청 팝업 표시
   - [ ] Access Token 저장 확인
   - [ ] hasCalendarAccess 플래그 확인

4. **캘린더 동기화 테스트** (2024-12-12 업데이트)
   - [ ] **TODOLOG 전용 캘린더** 자동 생성 확인
   - [ ] **todo(특정날짜) 할일** → 캘린더 이벤트 생성 확인
   - [ ] **routine 할일** → 캘린더 이벤트 생성 안됨 확인
   - [ ] **기간 할일** → 다중일 이벤트 생성 확인
   - [ ] **시간 처리**: 종일/1시간/정확한 duration 확인
   - [ ] **동기화 실패** → syncStatus = 'failed' 확인
   - [ ] **재시도 버튼** 표시 및 동작 확인
   - [ ] 구글 캘린더 앱에서 TODOLOG 캘린더 확인
   - [ ] 할일 수정 시 캘린더 이벤트 업데이트
   - [ ] 할일 삭제 시 캘린더 이벤트 삭제

5. **애플 로그인 테스트** (iOS, 추후 구현)
   - [ ] 로그인 성공 확인
   - [ ] 사용자 정보 저장 확인

---

## 10. 🎯 최종 구상 요약 (2024-12-12)

### 동기화 전략
- **범위**: todo(특정날짜) 타입만 동기화 (routine 제외)
- **방향**: 단방향 (앱 → 구글 캘린더)
- **캘린더**: "TODOLOG" 전용 캘린더 생성 및 사용
- **실패 처리**: 할일은 정상 생성, 동기화만 실패 상태로 표시

### 데이터 구조
```javascript
// User 모델 추가
{
  todoLogCalendarId: String, // TODOLOG 캘린더 ID
}

// Todo 모델 추가
{
  googleCalendarEventId: String, // 구글 캘린더 이벤트 ID
  syncStatus: String, // 'synced' | 'pending' | 'failed'
  lastSyncAttempt: Date, // 마지막 동기화 시도 시간
}
```

### 동기화 플로우
1. **할일 생성** → TODOLOG 캘린더에 이벤트 생성 → Event ID 저장
2. **할일 수정** → 캘린더 이벤트 업데이트
3. **할일 삭제** → 캘린더 이벤트 삭제
4. **실패 시** → syncStatus = 'failed' → 재시도 버튼 표시

### 시간 처리
- **시간 없음**: 종일 이벤트
- **시작시간만**: 1시간 duration
- **시작+종료시간**: 정확한 duration
- **기간 할일**: 다중일 종일/시간 이벤트

### UI 요소
- **홈화면**: `[ ] 우유마시기 (구글캘린더 등록 재시도버튼)`
- **설정화면**: 일괄 재시도 기능
- **상태 표시**: 실패한 경우만 표시

---

## 11. 📚 참고 자료

- [Google Sign-In for React Native](https://github.com/react-native-google-signin/google-signin)
- [Apple Authentication for React Native](https://github.com/invertase/react-native-apple-authentication)
- [Google Calendar API](https://developers.google.com/calendar/api/guides/overview)
- [Sign in with Apple](https://developer.apple.com/sign-in-with-apple/)
