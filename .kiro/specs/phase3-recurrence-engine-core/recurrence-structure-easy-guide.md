# 반복 일정 구조 쉬운 설명 문서

작성 목적: 개발자/기획자/리뷰어가 현재 반복 일정 데이터 흐름을 코드 없이 빠르게 이해하기 위함.

## 1. 한 줄 요약

현재 구조는 다음 3단계다.

1. SQL이 후보를 넓게 가져온다. (일정/완료/카테고리 포함)
2. recurrence 엔진이 반복 일정을 최종 판정한다.
3. 화면이 "일정 + 완료상태 + 카테고리 정보"를 합쳐 표시한다.

## 2. 비유로 이해하기 (편의점 버전)

1. 창고에서 물건을 넉넉히 꺼낸다. (SQL 후보 조회)
2. 유통기한/행사 규칙으로 다시 거른다. (엔진 판정)
3. 물건마다 스티커(완료 여부)와 진열 구역(카테고리 색)을 붙인다.
4. 진열대에는 최종 통과한 물건만 올린다. (UI 표시)

핵심은 "처음엔 넓게, 마지막엔 정확히"다.

## 3. 일정 종류

1. 보통 일정
- 단일 일정: 특정 하루만 보임
- 기간 일정: 시작일~종료일 사이에 보임

2. 반복 일정
- 매일/매주/매월/매년 규칙으로 반복

## 4. 데이터 3종류를 어떻게 가져오나

### 4.1 일정(Todo)

1. 날짜/월 범위 기준으로 SQL이 후보를 넓게 가져온다.
2. 단일 일정, 기간 일정, 반복 일정이 같이 들어온다.
3. 반복 일정은 이후 엔진 판정으로 진짜 표시일을 확정한다.

### 4.2 완료기록(Completion)

1. 같은 날짜(또는 달 범위)의 completion을 따로 조회한다.
2. 조회한 completion을 일정 목록에 병합해서 completed 상태를 만든다.
3. 결과적으로 UI는 "할 일 자체"와 "완료 여부"를 분리 저장한 뒤 합쳐서 본다.

핵심:

1. 일정 테이블과 완료기록 테이블은 분리되어 있다.
2. 화면 렌더 직전에 병합된다.

### 4.3 카테고리(Category)

1. 일정 조회 시 카테고리 정보를 JOIN으로 같이 읽어온다.
2. 카테고리 이름/색/아이콘이 일정에 붙는다.
3. 화면은 이 값으로 색 점(dot), 라벨 등을 그린다.

핵심:

1. 카테고리는 일정을 꾸미는 메타데이터다.
2. 일정 조회 단계에서 함께 붙여오므로 화면은 바로 표시 가능하다.

## 5. 화면별 현재 흐름

### 5.1 Todo Screen

1. 선택 날짜 기준으로 DB에서 Todo 후보를 가져온다.
2. 같은 날짜의 completion을 붙여 완료 상태를 만든다.
3. 카테고리 정보(색/이름)를 포함한 리스트로 렌더한다.

### 5.2 Todo Calendar

1. 보이는 월 + 주변 월(프리패치)을 묶어서 가져온다.
2. Todo/Completion을 월별 캐시에 저장한다.
3. 카테고리 색 정보를 함께 사용해 날짜 셀 점/표시를 그린다.

### 5.3 Strip Calendar

1. 주/월 스트립 범위 기준으로 데이터가 흘러간다.
2. 반복 일정 정밀 판정 경로를 todo-screen/todo-calendar와 완전히 통일하는 작업은 다음 단계다.
3. 완료기록/카테고리 병합 기준도 공통 경로에 맞춰 연결해야 한다.

### 5.4 Strip Calendar 월 모드 버퍼 정책 (중요)

Strip Calendar에 월 모드(Monthly Mode)가 있으면, "5주 버퍼"는 안전하지 않다.

이유:

1. 월 모드는 한 화면에 대략 5~6주(한 달 전체)를 동시에 소비한다.
2. 스크롤 중/모드 전환 시 화면이 다음 달 경계에 걸리면, 5주만 들고 있을 때 데이터 공백이 생기기 쉽다.
3. 결과적으로 "잠깐 비어 보임", "늦게 채워짐", "전환 시 깜빡임" 리스크가 커진다.

따라서 Strip 월 모드는 "3개월 윈도우"를 기본 정책으로 가져가야 한다.

정책:

1. 항상 [이전 달 + 현재 달 + 다음 달]을 한 번에 메모리에 유지한다.
2. 완료기록(Completion)과 카테고리(Category)도 같은 3개월 범위로 같이 가져온다.
3. 월 경계 근처 스크롤 또는 모드 전환 시, 다음 3개월 윈도우를 선로딩한다.
4. 윈도우 밖 데이터는 필요 시점에 재요청하고, 캐시는 점진적으로 정리한다.

## 6. 왜 통일 작업이 필요한가

SQL은 성능 때문에 "후보를 넓게" 가져온다.  
그래서 화면마다 마지막 판정 기준이 조금만 달라도 결과가 달라질 수 있다.

예:

1. 어떤 화면에서는 보이는데
2. 다른 화면에서는 안 보이는 현상

이걸 막기 위해 "최종 판정기(recurrenceEngine)"를 공통으로 쓰려는 것이다.

추가로 completion/category 병합 타이밍도 화면마다 다르면,

1. 어떤 화면에서는 완료로 보이는데
2. 다른 화면에서는 미완료로 보이거나
3. 카테고리 색/표시가 다르게 보일 수 있다.

그래서 "일정 판정 + 완료 병합 + 카테고리 표시" 경로를 같이 맞춰야 한다.

## 7. recurrenceEngine이 담당하는 역할

1. 입력 통일
- 문자열/객체/배열 형태의 반복 규칙을 하나의 표준 규칙으로 정규화

2. 단일 날짜 판정
- 특정 날짜에 이 일정이 실제로 발생하는지 true/false 판정

3. 범위 전개
- 시작~끝 구간에서 실제 발생 날짜 목록 계산

4. 안전장치
- 너무 긴 범위 계산은 가드(현재 366일)로 중단해 성능 리스크 차단

## 8. "1년 뒤 달력" 시나리오

사용자가 1년 뒤를 보더라도 문제는 없다.  
단, 내부 구현은 긴 구간 한 번 계산이 아니라 "월 단위/짧은 구간 분할" 방식으로 처리해야 한다.

즉:

1. 한 번에 과도한 범위를 확장하지 않고
2. 작은 구간 요청을 순차 처리해
3. 체감 성능과 안정성을 지킨다.

Strip 월 모드 관점에서는 "작은 구간"의 기본 단위를 3개월 윈도우로 잡는 것이 안전하다.

## 9. 다음 단계 작업(실제 해야 할 일)

1. 공통 조회/필터 경로 정리
- todo-screen + todo-calendar를 같은 엔진 최종 판정 경로로 통일

2. strip-calendar 연동
- 동일 엔진 경로를 strip에도 연결
- completion 병합/카테고리 반영도 같은 기준으로 정리
- 월 모드 데이터 버퍼는 5주가 아니라 3개월 윈도우로 고정

3. 회귀 테스트
- 같은 날짜/같은 일정/같은 완료상태/같은 카테고리 표시가 세 화면에서 동일한지 확인

4. 성능 테스트
- 일정이 많은 데이터에서도 스크롤/월 전환이 버벅이지 않는지 확인

## 10. 팀 공유용 핵심 문장

"DB는 후보를 넓게 가져오고, recurrenceEngine이 최종 판정을 담당한다.  
세 화면(todo, calendar, strip)이 같은 엔진 판정 + 같은 completion 병합 + 같은 category 표시 기준을 쓰도록 통일하는 것이 이번 단계의 핵심이다.  
특히 strip 월 모드는 5주 버퍼가 아니라 3개월 윈도우([이전/현재/다음 달])를 기본으로 가져가야 한다."

## 11. 최종 목표 흐름 (오프라인 퍼스트)

아래는 "최종적으로 맞추려는 목표 구조"다. (현재 일부만 구현됨)

1. 앱 시작
2. SQLite 초기화
3. 동기화 서비스 시작 (백그라운드, 화면 렌더를 막지 않음)
4. 공통 조회/집계 레이어
- 4-1. 로컬(SQLite)에서 후보 데이터 조회 (Todo / Completion / Category)
- 4-2. 일정 타입별 최종 판정 (공통 판정 함수 내부 분기)
  - 일반 일정(단일/기간): 날짜 범위 규칙으로 바로 판정
  - 반복 일정: recurrenceEngine 호출로 최종 판정
- 4-3. 판정 통과 대상 기준으로 `일정 + 완료 + 카테고리` 병합/집계
5. 화면 어댑터가 화면별 형태로 변환
6. todo-screen / todo-calendar / strip-calendar 렌더

동시에 뒤에서:

1. 동기화 트리거 감지 (앱 활성화 / 온라인 복귀 / 로그인)
2. `Pending Push` 수행 (로컬 변경분 서버 반영)
3. `Server Pull(Delta)` 수행 (서버 변경분 로컬 반영)
4. 반영 결과를 SQLite에 저장(Upsert/Soft Delete)
5. 캐시 무효화/재조회로 화면 자동 갱신
6. 실패 건은 pending queue 유지 + 재시도 정책으로 후속 처리

핵심:

1. 화면은 항상 로컬 기준으로 빠르게 뜬다.
2. 서버 반영은 뒤에서 안정적으로 따라온다.
