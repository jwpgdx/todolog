# Strip Calendar 문제점/검토 요청 정리서

## 0. 문서 목적

이 문서는 `strip-calendar` 주간/월간 전환 구조에서 발생할 수 있는 성능/구조 리스크를 정리하고,
외부 AI(Opus 포함)에게 검토를 요청하기 위한 기준 문서다.

핵심 질문:

1. 현재 설계가 메인 화면 성능 요구를 만족하는가?
2. 주 ↔ 월 전환 시 UI 트리/메모리/애니메이션 전략이 최적인가?
3. Phase 3 recurrence 통합 전/후 경계가 명확한가?

---

## 1. 컨텍스트

- 대상 화면: `TodoScreen` 메인
- 컴포넌트: `strip-calendar` (신규)
- 사용자 행동:
  1. Weekly: 좌우 스와이프 또는 `< >` 버튼으로 주 이동
  2. Monthly: 상하 스와이프로 무한 스크롤
  3. 하단 바 스와이프로 Weekly ↔ Monthly 전환
- 목표: 메인 화면이므로 매우 가볍고 일관된 UX 유지

참고 문서:

- `.kiro/specs/strip-calendar/requirements.md`
- `.kiro/specs/calendar-data-integration/phase3_recurrence_technical_spec_v3.md`

---

## 2. 이미 확정된 요구사항

1. 월간 리스트 구현체는 `@shopify/flash-list` 필수
2. `FlatList`를 월간 메인 경로로 사용하지 않음
3. Dot 정책:
   - 카테고리 중복 제거 후 표시
   - 최대 3개 dot 표시
   - 4개 이상이면 작은 `+` overflow 표시
4. 로컬 세팅 반영:
   - `language`에 따라 월/요일 텍스트 변경
   - `startDayOfWeek`(`sunday`/`monday`)에 따라 주 시작일 변경
5. 일정 데이터 연동은 UI shell 이후 연결
   - Phase 3에서 recurrence 통합 경로 확정 후 adapter로 연결
6. Monthly 스크롤 UX 확정:
   - `pagingEnabled={false}` (페이지 단위 끊김 금지)
   - `snapToInterval={WEEK_ROW_HEIGHT}` (주 행 단위 정렬)
   - `decelerationRate="fast"` (손을 뗀 뒤 과도한 미끄러짐 방지)
   - 목표: free scroll 감각은 유지하되 정지 시 partial-row 없이 주 상단에 정렬

---

## 3. 핵심 고민(문제 정의)

### 3.1 숨김 vs 언마운트

- 우려: 보이지 않는 월/주 UI를 단순히 `opacity: 0`, `height: 0`로 숨겨두면 리렌더/레이아웃 비용이 남아 성능 저하 가능
- 질문: 모드 전환 시 비활성 모드 UI를 즉시 `unmount`하는 것이 정답인가?

### 3.2 전환 시작 프레임 튐(Jank)

- 우려: Weekly 상태에서 Monthly 리스트를 전환 시작 시점에 mount하면 첫 프레임 비용으로 애니메이션이 튈 수 있음
- 질문: 전환 직전 pre-warm mount가 필요한가, 아니면 on-demand mount로 충분한가?

### 3.3 데이터 캐시와 UI 트리 분리

- 원칙 후보: 데이터(맵/캐시)는 남겨도 되지만 UI 트리는 최소 유지
- 질문: 이 분리가 실제 RN/FlashList 환경에서 충분히 성능 이점을 주는가?

### 3.4 주/월 앵커 동기화

- 우려: 전환 시 현재 주 위치를 월 리스트의 정확한 인덱스에 맞춰야 이질감이 없음
- 질문: `initialScrollIndex` + anchor 계산으로 충분히 seam-free가 가능한가?

### 3.5 Free Scroll + Week Snap 안정성

- 우려: `snapToInterval` 기반 정렬에서 row height가 실제 렌더 높이와 어긋나면 미세한 위치 오차/덜컥임 발생 가능
- 우려: `decelerationRate="fast"` 적용 후 기기별 체감이 과하게 빡빡해질 수 있음(iOS/Android 차이)
- 질문: "부드러운 이동 + 정지 시 주 단위 안착"을 만족하는 최소 설정 조합이 현재 안에서 충분한가?

---

## 4. 기존 의견 통합

### 4.1 개발자 A 관점 요약

- 가상화(Virtualization) 강제 필요
- 보이는 영역만 렌더하고 화면 밖은 recycle
- 월간 무한 스크롤에서도 메모리 상수 유지 필요

장점:

- 방향성 명확 (가상화 중심)

주의점:

- "안 보이는 데이터는 모두 즉시 삭제" 표현은 과장될 수 있음
- 실제 병목은 데이터 그 자체보다 UI 트리/리렌더 비용

### 4.2 개발자 B 관점 요약

- 데이터 캐시와 UI 트리를 분리
- 숨김이 아니라 unmount
- 기본은 3주만 렌더(21칸), 월은 필요 시만 렌더
- 렌더 중 dot/event 계산 금지

장점:

- 메인 화면 성능 관점에서 실전적
- "상수 렌더 트리 유지" 전략이 명확

---

## 5. 현재 예정 구현안 (초안)

### 5.1 렌더 전략

1. Weekly 모드
   - Prev/Current/Next 3주(21칸)만 유지
   - 좌우 스와이프와 `< >`로 주 이동

2. Monthly 모드
   - `FlashList` 기반 세로 무한 스크롤
   - Week row 단위 아이템 사용(가벼운 단위)
   - 뷰포트는 최대 6주 높이

3. 모드 전환
   - 하단 바 스와이프 감지로만 전환
   - 전환 완료 시 비활성 모드 UI 즉시 unmount
   - `scaleY` 대신 `translateY + overflow:hidden` 계열 사용 고려

### 5.2 데이터 전략

1. Dot 데이터는 "날짜별 unique category set" 기준
2. dot 계산은 렌더 단계가 아닌 사전 계산/캐시 결과 사용
3. DayCell은 최소 props + memo 적용
4. Phase 3 전에는 adapter 인터페이스로 분리하여 임시/빈 데이터 경로 사용 가능

---

## 6. 리스크 목록

1. 월 리스트 첫 mount 타이밍에서 프레임 드랍 발생 가능
2. 주 ↔ 월 인덱스 정렬 불일치 시 시각적 점프 발생
3. dot 캐시 무효화 누락 시 stale UI 발생
4. 전환 애니메이션과 리스트 재활용 시점이 꼬이면 flicker 가능
5. 모드별 컴포넌트 분리로 코드 복잡도 증가

---

## 7. 성능 수용 기준(검토 요청)

1. Weekly 모드에서 실시간 렌더 셀 수 상수 유지(21칸)
2. Monthly 고속 스크롤(상하) 시 blank area 무발생
3. 장시간 스크롤 후 메모리 사용량이 선형 증가하지 않고 plateau 유지
4. 모드 전환 반복 시 눈에 띄는 첫 프레임 튐 최소화
5. 날짜 선택/주 이동 시 입력 지연 체감 없음
6. Monthly free scroll 중에는 자연스럽게 이동하고, 정지 시 partial-row 없이 week boundary 정렬

---

## 8. 외부 AI에게 물어볼 질문

1. Weekly(3주) + Monthly(FlashList) + 상호 unmount 구조가 현재 RN 환경에서 Best Practice인지?
2. 월간 아이템 단위를 "week row"로 두는 방식이 "month item" 대비 실무적으로 더 안정적인지?
3. 전환 순간 월간 리스트 mount로 인한 jank를 줄이기 위한 권장 패턴은?
   - on-demand mount
   - pre-warm mount
   - idle-time pre-render
4. `initialScrollIndex` 기반 current week anchor 동기화 시 안정적으로 피해야 할 함정은?
5. Dot 캐시 무효화 범위를 어떻게 정의하면 stale/over-invalidation 균형이 좋은지?
6. 이 구조가 Phase 3 recurrence 통합(단일 계산 경로)과 충돌하지 않도록 인터페이스를 어떻게 고정하면 좋은지?
7. `snapToInterval={WEEK_ROW_HEIGHT}` 전제에서 row 높이를 고정 상수로 강제하는 게 맞는지, 혹은 동적 타입/폰트 스케일 대응 전략이 필요한지?
8. `decelerationRate="fast"`를 기본값으로 둘 때 플랫폼별 조정(특히 Android) 가이드가 필요한지?

---

## 9. 비범위(현재 단계)

1. recurrence 최종 계산/전개 로직 구현
2. recurrence-aware 단일 조회 경로 최종 확정
3. 서버/API 스키마 변경

---

## 10. 한 줄 결론

현재 방향은 "UI shell 우선 + 모드별 최소 렌더 + 비활성 unmount + 데이터 캐시 분리"이며,
남은 핵심 검증 포인트는 "모드 전환 순간의 jank 제어"와 "Phase 3 통합 인터페이스 고정"이다.
