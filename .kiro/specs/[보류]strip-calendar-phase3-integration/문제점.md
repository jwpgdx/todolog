이 문서는 한마디로 **“반복 일정(Recurring) 계산 규칙서 + strip-calendar 연결 가이드”**입니다.

핵심 목적

rrule 라이브러리 없이 반복 일정 계산.
날짜 오차 방지를 위해 dayjs + YYYY-MM-DD만 사용.
DB에 recurrence_end_date를 두고 성능/정확성 확보.
마이그레이션을 100개 배치로 처리해 앱 멈춤 최소화.
엔진에서 제일 중요한 규칙

new Date(), Date.parse(), toISOString().split('T')[0] 금지.
날짜 비교는 무조건 date-only 문자열(YYYY-MM-DD) 기준.
입력이 이상해도 앱 크래시 없이 fallback 처리.
DB/쿼리 요점

todos.recurrence_end_date 컬럼 유지.
인덱스: idx_todos_recurrence_window (start_date, recurrence_end_date).
SQL은 후보만 걸러주고, 최종 포함 여부는 엔진 함수로 확정.
strip-calendar 연동 요점 (이번에 보강된 부분)

stripCalendarDataAdapter가 로드/조회 경계 역할.
stripCalendarSummaryService가 day summary(date/hasTodo/dot) 생성.
useStripCalendarDataRange는 settle 시점에만 조회 트리거.
onScroll 프레임마다 fetch 금지.
테스트에서 봐야 할 것

파싱/전개 정확성(weekly/monthly/yearly, 윤년, 월말).
마이그레이션 재실행(idempotent) 안정성.
strip에서 weekly/monthly 동일 날짜 결과 일관성.
스크롤 중 per-frame 조회가 없는지.
구현 순서 요약

파서 강화(routineUtils).
엔진 구현(recurrenceEngine).
DB v4 배치 마이그레이션.
useTodos + strip adapter/summary에 엔진 연결.
무효화 범위 정리.
런타임 플래그 경로 검증.
성능/회귀 테스트.
원하면 다음 답변에서 이 문서를 기준으로 “개발자가 바로 시작할 체크리스트 10개”로 더 짧게 뽑아드리겠습니다.


아 이거 작업을 나누는게 낫겠네... 
rrule 라이브러리 없이 반복 일정 계산.
이것도 좀 공들여야 하는 작업 아님?

맞습니다. 이건 나눠서 가는 게 맞고, “공들여야 하는 작업”입니다.

이유는 3가지입니다.

반복 규칙 자체가 케이스가 많음
weekly BYDAY, monthly BYMONTHDAY, yearly 윤년/월말 등.
날짜 처리 실수하면 바로 오차 발생
그래서 문서에서 new Date() 금지, YYYY-MM-DD + dayjs를 강제한 겁니다.
성능/안정성 요구가 동시에 있음
계산 정확도 + 마이그레이션 배치 + UI 프레임 유지를 같이 맞춰야 함.
실무적으로는 이렇게 쪼개는 게 안전합니다.

엔진 순수 함수(파싱/판정/전개) 먼저 완성
테스트로 규칙 고정
DB 마이그레이션
useTodos 연결
마지막에 strip adapter 연결
원하면 다음으로 “이 순서 기준 tasks.md 초안” 바로 만들어드릴게요.


크게 나눠줘. 
1. rrule 커스텀 라이브러리
2. 그리고 strip-calendar 연동??

네, 크게 2축으로 나누는 게 가장 깔끔합니다.

Recurrence Core (rrule 대체 커스텀 엔진)
범위: 파싱/정규화/날짜 판정/범위 전개/엣지케이스/마이그레이션
산출물:
recurrenceEngine 순수 함수
routineUtils 확장
recurrence_end_date 백필/인덱스
엔진 단위 테스트(정확성 중심)
완료 기준:
useTodos에서 반복 판정이 안정적으로 동작
new Date() 없이 date-only 계약 준수
Strip-Calendar Integration (연동 단계)
범위: 엔진 결과를 strip에서 소비하도록 데이터 경로 연결
산출물:
stripCalendarDataAdapter에 recurrence-aware ensure/select 연결
stripCalendarSummaryService summary 출력 안정화
settle 기반 로드/캐시 무효화 연결
완료 기준:
weekly/monthly 동일 날짜 dot 일관성
per-frame fetch 없음
모드 전환 성능/앵커 정책 유지
이렇게 나누면,

1번은 “정확도 리스크”를 먼저 닫고
2번은 “UI/성능 리스크”를 나중에 닫는 구조라 안전합니다.
원하면 이 2축 기준으로 tasks.md를 바로 뼈대 작성해드리겠습니다.


연동은 todo screen, todo-calendar, strip-calendar
이렇게 되어야 하는거 아님? 지금 strip-calendar 이것만 빠져있는거지?

질문 의도는 “Phase3 연동 대상이 3군데( TodoScreen / todo-calendar / strip-calendar )가 맞는지, 현재는 strip만 미연동인지” 확인입니다. 코드 기준으로 현재 연결 상태를 빠르게 확인하고 정확히 답드리겠습니다.

Explored 2 files, 1 search
지금 상태를 정확히 구분해서 답드리려고 TodoScreen/useTodos와 strip 쪽 플래그까지 확인했습니다. 핵심은 “기존 반복 처리”와 “새 Phase3 엔진 연동”을 분리해서 보는 겁니다. 정리해서 바로 답드리겠습니다.

Worked for 21s
맞습니다. 최종 연동 대상은 3군데가 맞습니다.

TodoScreen (일자 Todo 목록)
todo-calendar (월 그리드)
strip-calendar (weekly/monthly strip)
다만 “무엇 기준으로 빠졌는지”를 나눠서 봐야 합니다.

현재 코드 기준

TodoScreen: 기존 경로로 반복 처리 동작 중 (useTodos -> getTodosByDate)
todo-calendar: 기존 캘린더 서비스 경로로 반복 후보 반영 중
strip-calendar: 데이터 요약 경로가 의도적으로 OFF
(ENABLE_STRIP_CALENDAR_SUMMARY = false, useStripCalendarDataRange)
Phase3 새 엔진 기준

새 recurrenceEngine으로 완전 통일 연동은 아직 미완료 상태
즉, 엄밀히 말하면 “strip만 빠진 것”이라기보다
“strip은 OFF 상태이고, 나머지는 기존 경로로 돌고 있는 상태”입니다.
요약하면:

제품 관점 연동 대상 3개 맞음
현재 눈에 띄게 미연동인 건 strip-calendar 맞음
Phase3 관점(새 엔진 단일화)으로는 전체 전환이 아직 남아있음

일단 제일 중요한게 recurrenceEngine 커스텀 엔진 만드는거지?

네, 맞습니다. 지금 단계에서 최우선은 recurrenceEngine 커스텀 엔진입니다.

이유:

정확성 기준점이 엔진에서 결정됨
todo-screen / todo-calendar / strip-calendar 3곳이 결국 같은 판정 로직을 써야 함
엔진이 먼저 고정돼야 연동 작업이 중복/회귀 없이 진행됨
즉 순서는 엔진 확정 -> 공통 경로 연결 -> strip 포함 UI 연동이 맞습니다.