
---

### ✅ [최종 확정] 데이터 처리 및 저장 로직

#### 1. 이벤트 저장 (클라이언트 → 서버)

**A. 시간이 있는 경우 (Timed Event)**

* **사용자 입력:** `2025-12-28` (날짜), `16:00` (시간)
* **처리:** **UTC 변환 절대 금지.** 입력받은 문자열 그대로 전송.
* `startDate`: `"2025-12-28"`
* `startTime`: `"16:00"`
* `userTimeZone`: `"Asia/Seoul"` (필수 전송)


* **서버/구글 연동 시:** 서버가 나중에 구글로 보낼 때만 위 3개 값을 조합해 UTC로 변환하여 `dateTime` 필드로 전송.

**B. 시간이 없는 경우 (All-day Event)**

* **사용자 입력:** `2025-12-28` (시간 없음)
* **처리:** 문자열 `"2025-12-28"` 그대로 전송. (`startTime`은 `null`)
* **서버/구글 연동 시:** 구글에 `date` 필드로 전송. (타임존 정보 제외)

#### 2. 반복 일정

**A. 일반 일정 (반복 OFF)**

* **UI:** 시작 날짜/시간, 종료 날짜/시간 자유롭게 선택.
* **데이터:** 입력한 값 그대로 전송.

**B. 반복 일정 (반복 ON)**

* **UI:** 종료 날짜 입력칸 숨김(시간만 노출). "반복 종료일" 별도 입력.
* **내부 로직:**
* `endDate`: 사용자 입력과 무관하게 **`startDate`와 동일한 날짜**로 강제 할당.
* `recurrenceEndDate`: 사용자가 입력한 반복 종료일(`2025-12-31`)을 별도 필드로 전송.



#### 3. 시간 입력 자동 보정 (UX 편의성)

* **상황:** 사용자가 시작 시간 없이 **종료 시간(마감 시간)만** 입력한 경우. (예: `endTime: "17:00"`)
* **처리:** 앱 내부에서 **시작 시간을 '1시간 전'으로 자동 계산**하여 채워줌.
* **결과:** `startTime: "16:00"`으로 자동 저장되어 캘린더에 [16:00 - 17:00] 블록 생성.
* (반대로 종료 시간이 없고 시작 시간만 있는 경우는 1시간 뒤로 설정하거나, 시작 시간만 저장하기도 함)

#### 4. 클라이언트 -> 서버 전송 데이터 (JSON Schema)

```json
{
  "title": "미팅",
  "memo": "준비물 챙기기",
  "categoryId": 1,

  // 1. 날짜/시간 (변환 없는 순수 문자열)
  "startDate": "2025-12-28",  
  "startTime": "16:00",       // 없으면 null (하루 종일)
  "endDate": "2025-12-28",    // 반복 설정 시 startDate와 동일값 강제
  "endTime": "17:00",         // 없으면 null

  // 2. 타임존 및 플래그
  "userTimeZone": "Asia/Seoul", // [필수] 나중에 서버가 UTC 계산할 때 사용하는 기준
  "isAllDay": false,            // [필수] startTime 유무와 별개로 확실한 플래그

  // 3. 반복 정보
  "recurrence": "RRULE:FREQ=WEEKLY;BYDAY=MO", // 값이 없으면 null
  "recurrenceEndDate": "2025-12-31"           // 값이 없으면 null
}

```

---
