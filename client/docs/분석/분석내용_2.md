네, 아주 좋은 생각입니다! **"이전 기술 검토 내용"**을 근거 자료로 포함하면 설득력이 훨씬 강해집니다.

특히 **"1~2ms vs 100~500ms"**라는 구체적인 수치 비교는 엔지니어들이 가장 좋아하는 데이터니까요.

보내주신 내용을 문서의 **[3. 기술적 근거]** 파트에 **핵심 비교표**로 녹여내고, 바로 이어서 **[실제 코드 수정 가이드]**까지 정리해 드렸습니다.

---

### 📋 [기술 의사결정 보고서] Offline-First 투두 앱 아키텍처 및 최적화 전략 (Final)

**작성 일자:** 2026.02.10
**주제:** 로컬 DB 캐시 무효화 전략 및 기술 스택 선정 근거

#### 1. 개요 (Executive Summary)

본 문서는 투두 리스트 앱의 **Offline-First(SQLite)** 특성을 고려하여, **데이터 캐싱 전략**과 **기술 스택**을 확정하기 위해 작성됨.

#### 2. 의사결정 : 캐시 무효화 (Invalidation) 전략

**결정:** 복잡한 `predicate`나 `setQueryData` 대신 **`invalidateQueries(['todos'])` (전체 무효화)** 전략을 채택한다.

#### 3. 기술적 근거 (Why?)

**① 비용 및 리스크 비교 (Previous Review Summary)**
기존의 서버 기반 앱과 현재 우리의 로컬 DB 기반 앱의 비용 구조는 완전히 다르다.

| 구분 | 일반 서버 기반 앱 | **SQLite 기반 Offline-First (우리 앱)** |
| --- | --- | --- |
| **쿼리 1회 비용** | 네트워크 100~500ms (느림) | **로컬 디스크 1~2ms (매우 빠름)** |
| **N개 무효화 시** | N * 100ms 지연 + 서버 부하 급증 | **N * 2ms ≈ 무시 가능 (부하 없음)** |
| **네트워크 비용** | 발생함 (데이터 소모) | **0 (비행기 모드에서도 동일)** |
| **코드 복잡도** | `setQueryData` 필수 (성능 위해) | **`invalidateQueries` 권장 (유지보수 위해)** |

**② 데이터 정합성 (Consistency)**

* **상황:** 일정 완료(Toggle) 시 캘린더의 '진행률'이나 '점 색상'이 변경되어야 함.
* **분석:**
* `setQueryData`: 리스트, 캘린더, 카테고리 뷰를 일일이 찾아서 수동으로 업데이트해야 함 → **버그 발생 확률 높음 (Human Error).**
* `invalidateQueries`: 모든 뷰가 DB의 최신 상태를 다시 읽어옴 → **데이터 무결성 100% 보장.**



**③ 성능 최적화 (React Query & FlashList)**

* **Lazy Refetch:** `invalidate`를 호출해도 화면에 보이지 않는(Inactive) 달(Month)의 데이터는 리페치하지 않음.
* **Unmount:** `FlashList` 사용으로 인해 화면 밖 컴포넌트는 메모리에서 해제되므로 렌더링 부하가 없음.

---

### 🛠️ [Action Plan] 코드 수정 가이드

위의 결정에 따라, 복잡한 캐시 관리 로직을 제거하고 **단순화(Refactoring)**를 진행한다.

#### 1. `useToggleTodo` (완료 체크) 수정

가장 빈번하게 호출되지만, 캘린더 갱신을 위해 전체 무효화가 필수적이다.

```javascript
// ❌ AS-IS (기존: 복잡한 분기 처리)
onSuccess: (data, variables) => {
  if (variables.recurrence) {
     // 날짜 계산하고 predicate 쓰고... (삭제 대상)
  } else {
     queryClient.setQueryData(...) // 수동 업데이트 (삭제 대상)
  }
}

// ✅ TO-BE (변경 후: 심플 통일)
onSuccess: () => {
  // 리스트, 캘린더, 카테고리 등 모든 뷰가 즉시 동기화됨
  // SQLite라 1~2ms면 충분함
  queryClient.invalidateQueries({ queryKey: ['todos'] });
}

```

#### 2. `useDeleteTodo` / `useUpdateTodo` 수정

일정이 삭제되거나 날짜가 바뀌면, 캘린더의 점(Dot) 위치도 바뀌어야 하므로 전체 갱신이 안전하다.

```javascript
// ✅ TO-BE
onSuccess: () => {
  // 삭제된 일정이 캘린더 점에서도 즉시 사라짐
  queryClient.invalidateQueries({ queryKey: ['todos'] });
}

```

#### 3. 캘린더 Dot 쿼리 점검

프론트엔드(JS)에서 점을 계산하지 말고, SQL 쿼리로 DB에게 위임한다.

```javascript
// ✅ TO-BE (useMonthlyDots)
// JS 연산 없이 DB가 중복 제거한 결과를 바로 사용
const result = await db.getAllAsync(`
  SELECT DISTINCT date, category_color 
  FROM todos 
  WHERE date LIKE '${year}-${month}%'
`);

```

---

### ✉️ 개발자에게 보낼 메시지

> "OO님, 지난번 기술 검토해주신 내용(SQLite 쿼리 비용 1~2ms 등)을 바탕으로 최종 의사결정 문서를 정리했습니다.
> **핵심은:**
> 1. 서버 통신 비용이 없으므로 `setQueryData`로직을 유지할 이유가 없음.
> 2. 오히려 `invalidateQueries`로 통일해야 **캘린더-리스트 간 데이터 불일치 버그**를 완벽하게 잡을 수 있음.
> 
> 
> 문서 하단에 **[Action Plan]**으로 코드 수정 가이드도 같이 넣었으니, 이 방향으로 바로 리팩토링 진행하겠습니다!"

이렇게 전달하시면 완벽할 것 같습니다! 바로 코드 수정 들어가시죠! 🚀