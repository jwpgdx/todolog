네, **"이 정도로 분석했으면 반박할 수 없다"** 싶을 만큼, **기술적 근거(Data & Logic)**와 **비교 분석(Trade-off)**을 꽉 채워서 작성했습니다.

단순한 의견이 아니라, **ADR(Architecture Decision Record, 아키텍처 의사결정 기록)** 형식으로 작성하여 전문성을 높였습니다. 동료 개발자가 읽었을 때 "아, 얘가 진짜 깊게 고민하고 결정했구나"라고 느낄 수 있도록 구성했습니다.

그대로 복사해서 공유 문서(Notion, Wiki)나 메신저에 올리시면 됩니다.

---

### 📄 [기술 검토 보고서] Offline-First 투두 앱의 캐시 전략 및 스택 선정 근거

**작성일:** 2026년 2월 10일
**작성자:** (사용자님 성함)
**주제:** 로컬 DB 환경에서의 최적화 전략 및 라이브러리 선정 (WatermelonDB vs SQLite)

---

### 1. 개요 (Executive Summary)

본 문서는 현재 개발 중인 투두 리스트 앱의 **오프라인 퍼스트(Offline-First) 아키텍처**를 고려하여, **데이터 캐싱 전략**과 **기술 스택 유지 여부**를 재검토한 결과를 기술한다.

**[핵심 결정 사항]**

1. **캐시 전략:** 복잡한 부분 갱신(`predicate`) 대신 **전체 무효화(`invalidate-all`)** 전략을 채택한다.
2. **기술 스택:** WatermelonDB/TinyBase 등의 도입을 보류하고, **SQLite + React Query** 조합을 유지한다.

---

### 2. 아키텍처 컨텍스트 (Context)

의사결정의 배경이 되는 현재 시스템의 특성은 다음과 같다.

* **Offline-First:** 모든 데이터는 로컬 **SQLite**에 우선 저장되며, UI는 오직 로컬 DB만을 참조한다. (서버 API 직접 호출 ❌)
* **Sync:** 서버 동기화는 백그라운드 프로세스에서 별도로 수행된다. (UI 렌더링과 분리됨)
* **Data Scale:** 사용자당 평균 1,000~10,000건의 텍스트 데이터 예상.
* **UI Components:** `FlashList`를 사용한 가상화 리스트(Virtualized List) 및 월별 캘린더 뷰.

---

### 3. 의사결정 I : 캐시 무효화 (Invalidation) 전략

**[논쟁 점]**
데이터 변경(CRUD) 발생 시, `predicate`를 사용하여 변경된 날짜만 정밀 타격할 것인가, `queryKey` 전체를 무효화할 것인가?

**[결정]**
👉 **`queryClient.invalidateQueries({ queryKey: ['todos'] })` (전체 무효화) 사용**

**[기술적 근거 상세]**

**1. 비용 분석 (Cost Analysis)**

* **네트워크 비용:** `0`. 본 앱의 `queryFn`은 로컬 SQLite를 조회하므로, 전체를 무효화해도 서버 요청은 단 1회도 발생하지 않는다. (데이터 요금, 배터리 소모 이슈 없음)
* **I/O 비용:** SQLite는 인메모리에 가까운 속도를 낸다. 1,000건 조회 시 쿼리 실행 시간은 약 **1~2ms** 내외로, UI 스레드를 차단(Block)할 수준이 아니다.

**2. React Query의 동작 메커니즘 (Active vs Inactive)**

* 우려 사항: *"전체를 무효화하면 1월부터 12월까지 모든 데이터를 다시 읽어오는가?"*
* 팩트: **아니다.** `invalidateQueries`는 데이터를 `stale`(상함) 상태로 마킹할 뿐이다.
* **Active Query (현재 화면):** 즉시 `refetch` 수행. (예: 현재 보고 있는 2월 리스트)
* **Inactive Query (화면 밖):** `refetch` 하지 않음. 사용자가 스크롤하여 해당 월을 볼 때 비로소 `refetch` 함.


* **FlashList 효과:** 스크롤을 내려 화면에서 사라진 컴포넌트는 Unmount 되며, 관련 Query는 `Inactive` 상태가 되므로 불필요한 백그라운드 연산이 발생하지 않는다.

**3. 데이터 정합성 (Data Consistency) 및 버그 방지**

* **문제 상황:** 일정을 수정했는데 캘린더의 '카테고리 점(Dot)' 색상이 갱신되지 않는 동기화 문제.
* **해결:** `predicate`로 일일이 의존성을 추적하는 것은 휴먼 에러를 유발한다. 전체 무효화를 통해 **List View, Calendar View, Search View**가 항상 **'단 하나의 진실(Single Source of Truth, DB)'**을 바라보게 강제함으로써 데이터 불일치 버그를 원천 차단한다.

---

### 4. 의사결정 II : 데이터베이스 라이브러리 선정

**[논쟁 점]**
현재의 `SQLite + React Query` 구조를 유지할 것인가, `WatermelonDB`나 `TinyBase` 같은 특수 목적 라이브러리로 마이그레이션 할 것인가?

**[비교 분석]**

| 후보군 | 특징 | **기각 사유 (Rejection Reason)** |
| --- | --- | --- |
| **WatermelonDB** 🍉 | - 대용량(10만+) 최적화<br>

<br>- Lazy Loading 기본 지원<br>

<br>- 동기화 엔진 내장 | **1. RN 호환성:** React Native 0.76+ (New Arch) 환경에서 빌드 설정 복잡도가 매우 높음.<br>

<br>**2. Over-engineering:** 현재 데이터 규모(수천 건)에 비해 도입 비용(Boilerplate)이 과도함.<br>

<br>**3. SQL 미지원:** SQL의 강력한 쿼리 기능(GROUP BY 등)을 포기해야 함. |
| **TinyBase** 💎 | - 인메모리 반응성<br>

<br>- CRDT 동기화 | **1. 메모리 리스크:** 모든 데이터를 RAM에 로드하므로, 데이터 증가 시 **OOM(Out Of Memory)** 발생 위험 존재.<br>

<br>**2. 쿼리 한계:** 복잡한 날짜 범위 검색이나 통계 처리가 SQL보다 비효율적임. |
| **Legend-State** ⚡ | - 초고속 렌더링<br>

<br>- 가벼운 상태 관리 | **1. DB 역할 부재:** 단순 상태 관리에 특화되어 있어, 관계형 데이터(Relation) 처리에 부적합.<br>

<br>**2. 동기화 부담:** 서버 동기화 로직을 바닥부터 직접 구현해야 함. |

**[결정]**
👉 **현재의 `SQLite + React Query` 아키텍처 유지**

**[선정 이유]**

1. **안정성(Stability):** 표준 SQL을 사용하여 플랫폼(iOS/Android) 특성을 타지 않고 안정적으로 동작함.
2. **유지보수성(Maintainability):** 새로운 ORM 문법을 학습할 필요 없이, 익숙한 SQL과 React Query 패턴을 사용.
3. **성능(Performance):** 10,000건 이하의 데이터에서는 SQLite의 인덱싱(Indexing)만으로도 충분한 퍼포먼스(16ms 프레임 방어)가 보장됨.

---

### 5. 최종 결론 (Conclusion)

우리는 **"서버 통신이 없는 로컬 DB 환경"**이라는 특수성을 최대한 활용해야 한다.

1. **최적화 관점:** `Predicate`를 통한 마이크로 최적화는 현재 환경에서 실질적인 이득(네트워크 절약 등)이 없으며, 오히려 코드 복잡도와 버그 가능성만 높인다. 따라서 **단순하고 강력한 `invalidate-all` 전략**이 엔지니어링 적으로 올바른 선택이다.
2. **스택 관점:** 유행하는 라이브러리로의 전환 비용(Migration Cost)을 치르는 대신, 현재 검증된 아키텍처 위에서 **기능 구현에 집중**하는 것이 프로젝트 성공 확률을 높인다.

---

### ✉️ (옵션) 동료에게 보낼 메시지

> "OO님, 제가 최근 고민했던 **캐시 무효화 로직**과 **DB 라이브러리 선정** 관련해서 기술 검토 내용을 정리했습니다.
> 결론적으로 말씀드리면:
> 1. 우리 앱은 **로컬 SQLite**를 쓰기 때문에 `invalidate`를 전체로 걸어도 네트워크 비용 0원, 성능 저하도 거의 없습니다. 오히려 부분 갱신하려다 캘린더 점(Dot) 꼬이는 버그 잡는 비용이 더 크다고 판단했습니다.
> 2. WatermelonDB 등은 현재 RN 최신 버전 호환성 이슈와 러닝 커브 때문에 도입 리스크가 크다고 판단하여, 현재 스택을 유지하는 쪽으로 가닥을 잡았습니다.
> 
> 
> 자세한 기술적 근거는 첨부 문서에 정리했으니 확인 부탁드립니다!"